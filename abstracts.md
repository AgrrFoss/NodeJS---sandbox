# Конспект по курсу BackEnd
___
## Занятие от 10.04.2024. Начало работы с TS
### Первые 20-30 минут - настройка среды под линукс.
### Начало работы с TS - 19:05
* Установить  ts глобально
 sudo npm install -g typescript
глобально устанавливается компилятор tsc.
* создать файл с расширением .ts
* скомпилировать ts в js
* Запустить ```node hello.js```

Код в обратную сторону провернуть нельзя.
### Инициализация проекта на ТС 19:28
```tsc --init```
создастся файл tsconfig.json, после его создания не обязательно передавать все файлы параметрами команды tsc
достаточно казать их  в tsconfig.json, после чего командой ```tsc``` компилируется весь проект.

### Пакет ts-node - 19:40
позволяет выполнять тайпскрипт без предварительной компиляции
```sudo npm install -g ts-node``` - удобно для разработки.
```ts-node -v```
```ts-node filename.ts```

### Перевод 12го проекта на ts - 19:47

При компиляции произойдет перевод кода в commonJs это надо учитывать и возможно изменить настройки в package.json

### Декораторы - 2:30

___

## Занятие от 16.04. Запуск проекта на NESTjs
### Глобальная установка Nestjs Командой ```sudo npm i -g @nestjs/cli```
 
CLI - Command Line Interface - Командный интерфейс, который позволяет автоматизировать некоторые процедуры в проекте  

```nest --help``` - позволяет увидеть все команды.  

```nest new "project_name"``` - создаст дирректорию и в ней проект  
```nest new --directory ./ "project_name"``` - Создает проект в существующей директории с заданным именем
### Решение конфликта с Гитом  с 00:38:00
При попытке сделать первый коммит возникает кофликт, так как Nest создал свой гит реопзиторий.
###  Запуск проекта. 00:50:00
### Порядок действия для запуска проекта 1:19:00
### Подключение переменных окражуения 1:30
У nestjs есть модуль config, который позволяет получать пременные окружения  
Для этого потребуется модуль ```npm install @nestjs/config```
Добавляем внутрь функции bootstrap в main.ts  
>const configService = app.get(ConfigService);
### Подключение импортов в Nestjs 1:39-1:43
Чтобы модуль стал доступен нужно в app.module.ts импортировать ConfigModule
в imports [] сконфигурировать, передав метод ConfigModule.forRoot ({})
### 1:43 - 1:47 - Решение проблемы с ipv6
Для корректного отображения ip-адреса приложения необходимо задать второй параметр

>await app.listen(port, '0.0.0.0'); 
 
### 1:47 - 2:07 Описание струкруры проекта в Nestjs

### 2:07 Проверка проекта в Postman

### Добавление в проект своих путей запросов и ответов.
По умолчанию в заголовке ответа Нест отвечает строкой "Hello world" для изменения этого поведения небоходимо изменить код в разделе
> AppService.ts

По умолчанию Нест получает входящие данные на роутер "/", изменить это поведение можно в контроллерах, добавив
строку с необходимым адресом в app.Controller.ts
В декоратор контроллера базовый роут
в декоратор Get строка для get запроса.


```
import { Controller, Get } from '@nestjs/common';
import { AppService, ITestResponse } from './app.service';

@Controller('/api/v1.0')
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('/contacts')
  getHello(): ITestResponse {
    return this.appService.getHello();
  }
}
```
Роут /api/ можно переопределить еще более глобально в main.ts 

### Переработка проекта с разделением на модули - 2:23.
Структура с изменениями в контроллер и сервис допустима только в случае, когда на весь 
проект 2-3 ендпоинта(роута), если роутов больше, необходимо разделение проекта на чатси.
Для этого используется CLI интерйфейс.

```
nest g res
```
после чего пишем имя ресурса, выбираем тип Rest Api, и подверждаем желание создания CRUD entry points
команда создает готовый круд модуль - дирректорию, содержащую:
* главный файл - модуль,
* Сервис с функциями обработки запроса
* Контроллер с энпоинтами и методами запроса
* entities (Сущности) - заготовка для взаимодействия с TypeOrm
* dto - Проверяет входные объекты получаемые из запросов, елси качественно составить dto не потребуется писать валидацию

### Изменение структуры проекта, удаление базового сервиса и контроллера - 2:37.
Для проектов с большим количеством ентрипоинтов можно из главного модуля удалить импорты:
* app.controller.ts
* app.service.ts


### Добавление статичных файлов фронтенда в проект - 2:43.

Выносим импорты в отдельные конфиги.
Добавляем модуль  `npm install @nestjs/serve-static`
ЧТобы сделать путь относительным потребуется метод **join** из node:path


___

## Занятие от 17.04. Подключение базы данных постгресс.
в каталоге Src:
```nest g res```
указываем сущность, которую хотим создать например "users"
ентер => yes
 создастся 5 файлов, нам нужны 3, без тестов

Модели БД лежат в папке entities, эти entities надо определить.

Реализуем подключение к БД. Для этого потребуется модуль TypeOrm

Выходим в каталог проекта, где лежит нода, там выполняем
```npm i @nestjs/typeorm typeorm pg```
в app.module.ts импортируем  typeorm и регистрируем его в импортах.

### Подключение переменных окружения и получение хоста БД. 00:37 - 00:50.
из ConfigService создается отдельный экземпляр и берем из него метод гет



```
const ormConfig: TypeOrmModuleOptions = {
 type: "postgres",\
 host: configService.get('NODEAPP_HOST', 'localhost' ),\
 port: ...\
 ...\
 entities: [join(__dirname, '**', '*.entity{.ts,.js}')] //файлы js нужны так как после компиляции ts не будет.\
 synchronize: true - в продакшене выключается в false
}
```

### Запуск проекта в 00:59 - Выпадает в ошибку окружений.
Импортируем config  from 'dotenv'
выполняем config();

### Создание первых таблиц в БД - 1:09.
Задекорировать классы в entities с помощью @Entity
  и дальше создается структура класса.
```
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity ()
export class Role{
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;
}
```
### Создание связей многих ко многим - 1:23
Для связи таблиц многие ко многим используется специальный декоратор
Перед импортом ентитис их надо зарегистрировать в module.ts
Далее для связи ентитис импортируются друг в друга
```
import { Entity, PrimaryGeneratedColumn, Column, ManyToMany } from 'typeorm';
import { Role } from '../../roles/entities/role.entity'
...
@ManyToMany( () => Role, (role) => role.users)
  roles: Role[];
```
 Перезапуск базы данных __1:27__ - изменения не актуализировались  
 Решение в __1:35__ - забыт важный декоратор
`@JoinTable()`  



### Создание дампа БД. 1:42.

В Дибивере - правый клик на базе данных - инструменты - резервная копия.
Не прокатит без локального установленного клиента постгреса. (Сервер из докеране прокатит)

Для создания Дампа БД используется ПГадмин.  
__1:46__ выгрузка дампа  и проблема с кодировкой.
__1:49__ - правильная выгрузка Дампа

### Работа с дампом 1:52.
Сокращение и доработка дампа Базы данных до 2:10.

### Доработка моделей пользователя и ролей
```
@Column( {nullable: true}) //позволяет оставлять поле пустым.
theDescription: string;
```

### Измененяем способ наименования в БД.  2:15
Устанавливаем модуль 
` npm instal typeorm-naming-strategies`

Добавляем его в конфиг orm
`namingStrategy: new SnakeNamingStrategy(),`

### Подготовка постман к работе с Апи. Копирование запросов. 2:27
 Импортируем InjectRepository в  Service
добавляем его в конструктор с помощью декоратора с приватным свойством userRepo  
` constructor(@InjectRepository(User) private userRepo: Repository<User>) {}`  
после чего обращаемся через this к этому свойству например так.
```
 findOne(id: string) {
    return this.userRepo.findOne({where: {id}});
  }
```

--- обрыв связи с 2:38 до 2:44  ---

### Описание DTO. 2:48
дЛя валидации данных устанавливается модуль 
`npm install class-validator`
После импорта с помощью декоратора можно использовать для валидации данных 

```
import { isString } from 'class-validator';
export class CreateUserDto {
  @isString()
  login: string;
  @isString()
  password: string;
}
```
___

## Занятие от 21.04. Добавление возможности связи между пользователями и ролями.

Первые 30 минут - попытка зпустить проект под виндой.  
32:00 Копирование коллекции в постман для ролей  
35:00 Копирование АПИ ролей и проверка стандартного круд.  
45:00 - Продумывание логики связывания ролей с пользователями  
53:00 - создали маршрут присвоения ролей в постмане  
### 56:00 - Создание логики в Апи
Прописываем метод в контроллере:
```
 @Patch('assign-roles/:id')
assignRoles(@Param( 'id') id: string, rolesDto: any) {
}
```

В конструктор класса user.services необходимо заинжектить и прописать сам метод
```
...
@Injectable()
export class UsersService {
constructor(@InjectRepository(User) private userRepo: Repository<User>,
@InjectRepository(Role) private roleRepo: Repository<Role>
){}
...
 async assignRoles(id: string, rolesDto: RolesDto) {
    const foundUser =  await this.userRepo.findOne({where: {id}}); //Проверяем что такой пользователь есть вбазе

  }
...

```
В модуль users.module в ентитиз необходимо добавить Role
```
...
import { Role } from '../roles/entities/role.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([User, Role]),
  ],
 ...
```
### Отсутствие понимания какую ошибку вернуть пользователю
1:25 - Написана логика работы с объектом пользователя.

```
 async assignRoles(id: string, rolesDto: RolesDto) {
try {
const foundUser = await this.userRepo.findOne({ where: { id } }); //Проверяем что такой пользователь есть вбазе

const roles: Array<Role>=[] // создаем массив ролей

  for (const roleId of rolesDto.roles) {
  roles.push(await  this.roleRepo.findOne({where: {id: roleId}}));
  }
  //validation Ok
  const updatedUser = await this.userRepo.save({ ...foundUser, roles });
  return updatedUser;
  } catch (err) {
  throw new BadRequestException({error: 'Error assign roles'});
  }
  }
```
Отправка запроса с пустыс массивом - снимает все роли с пользователя.

### Защита пароля в базе данных - 1:49.
Использование библиотеки для шифрования и хеширования bcrypt;
С помощью переменной saltOrRound можно зашифровать пароль. переменную обычно хранят в переменных окружения или на отдельном сервере.  
```
npm i bcrypt
npm i -D @types/bcrypt
```
__2:09__ - Проверка работоспособности защиты пароля. Все работает.

### Изменяем отправку данных пользователей, для удаления оттуда паролей. - 2:15
Добавляем декоратор `@Exclude` в entities - не работает.

в create-user.dto добавляем этот декоратор и получаем ошибку.  
__2:18__ - Для получения нужного результата в  user.entity декоратору добавляется 
объект `{select: false}`
```
  @Column({select: false})
password: string;
```
но при создании и изменении пользователя пароль все равно возвращается.  
__2:25__ - Поставленная задача решена, делаем коммит.

2:52 - пробуем добавить 2 одинаковых комплекта данных. и Фиксим это.


___
## ЗАнятие от 24.04. Аутентификация

### Работа с гитом
`git checkout -f` Возвращает последнее состояние проекта, которое было закоммичено в выбранной ветке

### Объяснение проделанной структуры работы. 18:48.
Зачем скидывать тесты в гит  
18:52 - Как просмотреть версии файлов в вебшторме, сохраненные в гите  
19:02 - База данных подключена, в ней есть необходимые таблицы.  
19:05 - Тестирование работы сервиса. Добавление данных.
19:09 - Объяснение структуры БД

### Вопрос про Репозитории. 19:14.
Подробное объяснение декораторов, контроллеров ентитис  
19:26 - Ентити менеджеры и репозитории, объяснение на примере документации TypeOrm  
19:20 - ПОтерял нить повествования  
19:35 - Объяснение на примере проекта, что такое репозиторий.

### Начало работы с аутентификацией. 19:53.
В документации Nestjs заходим в раздел Security/
Нам нужне раздел __Authentification__  
Рекомендуется пройти все шаги атентификации вручную, хотя-бы до  __Enable Authentification global__  
20:04 - Про библиотеку Pasport
### Работа с библиотекой Pasport. 20:07.
Объяснение, что будем делать дальше - подготовка постмана.
Для регистации на эндпоинт __signin__ будет уходить пост запрос с __username и password__  
20:19 - Объяснение работы с Токенами в Постмане
Для реализации аутентификации необходимо передавать соответствующий заголовок.

1:55 - Начало работы с проектом.  
Потребуется установить следующие модули:
```
npm install --save @nestjs/passport passport passport-local
npm install --save-dev @types/passport-local
```
потребуется создать модуль аутентификации, в каталоге src
```
nest g module auth
nest g controller auth
nest g service auth
```

2:00 - Модули созданы, объяснение разницы с созданием ресурсов. У модулей не создается ентитиз и дто.
Модули автоматически импортируются в app.modules
2:06 копирование метода findOne из User.
Получаем хеш пароля и выполняем поиск пользователя с параметром  
`where: {login: userName, password: passwordHash}` 
заменям запрос пароля на константу для исключения дублирования кода.
### Пишем сервис для аутентификации 2:13
Импортируем туда ЮзерСервис и пишем метод SignIn()
В AuthModule импортируем UsersModule
### Создаем контроллер и ДТО

### Написаны Сервисы, Контроллеры, ДТО модуля авторизации 
Падает с ошибкой 2:30.

В модуле аутентификации необходимо импортировать модули юсер и роль.  
2:37 получаем ошибку при любом пароле.

2:59 - Ошибка найдена, неправлиьно применялся метод при сравнивании паролей.
Для сравнения пароля юзера и пришедшего хеша используется метод bcrypt.compare()  
`return await bcrypt.compare(password, foundUser.password)`.
Но так как мы пароль не получаем с юзером метод не работает, нужно либо убрать 
`{select: false}` из  user.entity
Фиксится добавлением объект опций:
```
const foundUser = await this.userRepo.findOne({
        select: ['login', 'password'],
        where: { login: username }
      });
```
3:07 - Объяснение того, что было проделано.

___

## Занятие от 27.04.2024. Добавление Passport для работы с JWT.
18:37 - Вспоминаем проделанное.
18:40 идем по докусментации нест, раздел секьюрити - паспорт.
Добавляем локальную стратегию
### 19:01 существуют класс -  authGuard

19:17 - Запуск сервиса и проверка его жизнедеятельности.
Пока запускается докер слушаем вводную про CURL.
19:25 - проверка через постман, смена пароля пользователя, успешный результат.
19:28 - звонок до 19:31.
19:40 - объяснение Guarda. Он говорит фреймворку - когда приходит запрос - достается боди и запускает его данные в 
локальную стратегию из файла local.strategy.ts.
ДО 19:49 - Разбираем стратегии и  Guard

### JWT 1:26 
Устанавливаем необходимые модули.
```
npm install --save @nestjs/jwt passport-jwt
npm install --save-dev @types/passport-jwt
```
1:32 - в  auth.service передаем jwtService и создаем там метод логин
в контруктор контроллера передаем authService и возвращаем из него метод login при запросе на signin  
 в auth.module необходимо зарегистрировать jwtModule
```
JwtModule.register({
      secret: configService.get('JWT_SECRET', 'SimpleSecret'),
      signOptions: { expiresIn: configService.get('JWT_EXPIRES_IN', '60s')}
    }),
```
1:38 настройка jwt модуля для работы с переменными окружения  
1:44 Проверка jwt на сайте jwt.io  
1:49 Настройка преедаваемых данных от jwt  
### Добавление id пользователя в payload JWT
чтобы добавить id в jwt потребуется добавить получение айдишника в метод findUser в user.service 
после чего айдишник станет доступен как свойство объекта user `const payload = { username: user.login, sub: user.id };`  
### Защита остальных ендпоинтов
Для этого необходимо определить еще одну стратегию в файле jwt.strategy.ts. Копируем туда все из документации и 
останется только переопределить метод валидации
JwtStrategy добавляется в AuthModule

Далее с помощью декоратора `@UseGuards(JwtAuthGuard)` мы можем в контроллерах защитить методы.  
2:08 объяснение, как работать с токкенами в постмане
2:15 Раскопируем декоратор, для защиты всех ендпоинты


___
## Занятие от 4.05.  Авторизация.

Первые 10 минут - сброс триала ВебШторма. Не прокатило, перешли на Линукс  

Механизм управления пользователями и ролями не должен быть доступен кому попало - в этом и заключается процесс авторизации.  
Создается роль пользователя, роль администратора

### 00:30 - исправление бага с регистрацией одинаковых пользователей.
Для этого в user.entities.ts для логина юзера задается `@Column({unique: true})`

### Объяснение работы авторизации - 00:45.
1. Создается отдельный гард для защиты некоторых роутов, дающий доступ только пользователям с определенными ролями  `nest g guard`
2. В появившемся файле roles.guard.ts прописывается логика защиты роута  
Метод делается асинхронным для возможности использовать в нем await. в констуктор класса инжектим репозиторий Юзер, чтобы иметь доступ
к БД списку пользователей, достаем массив ролей пользователя и проверяем есть-ли нужная нам роль в этом массиве, если есть возвращаем true 
```
const ADMIN_ROLE = 'admin';
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(@InjectRepository(User) private userRepo: Repository<User>) {}
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const { user } = context.switchToHttp().getRequest();
    const userId = user.userId;
    const userWithRoles = await this.userRepo.findOne({
      select: ['id', 'login', 'roles'],
      where: { id: userId },
      relations: ['roles'],
    });
    const receivedRoles = userWithRoles.roles.map((role: Role) => {
      return role.name;
    });

    return !!receivedRoles.includes(ADMIN_ROLE);
  }
}
```
В таком случае мы получаем захардкоженую роль пользователя.
Дальше достаточно указать этот гард в декораторе защищающем запрос.

### Делаем метод авторизации универсальным 1:18
Поставив в защищаемом эндпоинте декоратор `@SetMetadata('roles', ['admin'])` мы декларируем Метаданные и инжектируем в конструкторе приватное свойство
`private reflector: Reflector,`
Дальше получаем список ролей 
```
const allowedRoles = this.reflector.getAllAndOverride('roles', [
      context.getHandler(),
      context.getClass(),
    ]);
```
Подробнее можно ознакомитьс я а документации fundamentals -> Execution context

Чтобы код выглядел приличнее создается отдельный декоратор __roles.decorator.ts__ для user.controller
Который будет наследоваться от SetMetadata
```
import {SetMetadata} from "@nestjs/common";
export const Roles = (...roles: string[]) => SetMetadata('roles', roles); // Деструктуризируем входящие данные.
```
и использоваться весто нее в  __user.controller.ts__
```
  @Roles('admin', 'user')
@UseGuards(JwtAuthGuard, RolesGuard)
@Get()
findAll() {
return this.usersService.findAll();
}
```

### Раскопируем декораторы для защиты других ендпоинтов - 1:55

###  Реализуем добавление к каждому новому зарегистрированному пользователю роли Юзер
2:00 затык с ролями до 2:13 дальше проверка работоспособности.

### Настройка автоматического добавления роли администратора - 2:20
При регистрации пользователя с именем  admin система будет автоматически добавлять роль admin, чтобы мы всегда имели

### Что почитать после. 2:40.
 Role Based Access Control -  В системе есть роли, на основе имеющейся у субъекта роли система решает, может ли он иметь доступ к тем или иным объектам  
 Claims-based autorization - с пользователем сопоставляеются  permissions 
 ___

## Занятие от 08.05. Вопрос ответ, грамотная настройка VDS

18:32 - Вопрос про доккер.
у докера внешнийпорт:внутреннийпорт - внутренний порт должен быть уникален в пределах композы.
При запуске докера система ругается на конфликт ВНЕШНИХ портов
Если pgAdmin работает через докер, то он обращается к постгресу внутри контейнера и обращается через postgres:ВНУТРЕННИЙпорт
18:50 - про сохранение данных в докере, не совсем уловил суть.
19:00 - про отключение автозапуска
`systemctl disable docker` - Отключить автозапуск докера.
`systemctl enable docker` - Добавить докер в автозапуск

`docker compose ps` - работает только в каталоге, в котором лежит файл ямл и показывает только связанные с ним композы
`docker ps` - работает во всей системе и показывает все запущенные контейнеры.
`docker ps -a` - показывает вообще все контейнеры.

### Файлы  docker-compose.yaml  и dockerfile

в dockerfile описывается, что мы хотим сделать на основе существующего образа.
Чтобы разобраться с этим файлом можно посмотреть лекцию по докеру, ссылка на который была в чате когда проходили докер.

19:40  - yaml - файлы - это обычно конфиги, надо читать, что значит это расширение и как его использовать.
### Делаем проект, который будет универсально запускаться. 19:44
 Задаем container_name: ___ каждому контейнеру, чтобы его было проще найти. Остановив предыдущую конпозу запускаем новую, чтобы не было конфликтов портов.

### Делаем коммит и переключаемся на VDS - 20:27
Подключение к серверу через ssh - 20:21
`ssh root@147.45.137.195 -p 22` - пользователь@IP -p порт
Дальше нас просят ввести пароль, после чего мы попадаем на сервер.
настраиваем службу ssh
`systemctl status ssh`
`nano etc/ssh/sshd_config.d/*`
Там можно поменять порт на любой другой. но дальше стоит его проверить  с помощью команды netcat
`netcat -l 8822`
 с другого терминала
 `netcat 147.45.137.195 8822`
дальше преезапускаем сервер 
`systemctl restart ssh`

дальше в конфигурационном файле можно отключить Permitrootlogin, тогда нельзя будет зайти под логином.

На своем компьютере можно создать `ssh-keygen` указать в конце название ключа(так будет называться файл).
В строке rsa.pub В конце можно ключ подписать, чтобы его можно было идентефицировать.
20:37
Возвращаемся на сервер, переходим в домашний каталог:
`cd`
и переходим в папку
`cd/.ssh`
создаем файл
`nano autorized_keys`
 вставляем туда ключ и сохраняем

На своем компе 
`ssh -i ./ssh root@147.45.137.195 8822` - в команде указывается местоположение ключа, имя пользователя@IP порт.

В каталоге на локальном компе в папке ssh можно создать локальный конфиг
`.ssh/config` без расширения и туда вставить 
```
Host timeweb 
  Hostname 147.45.137.195
  Port 8822
  IdentityFile ~/.ssh/timeweb
  User root
```

после чего можно подключаться к удаленному серверу через команду 
`ssh timeweb`
20:55
На сервере с использованием `pwgen 16` команда и количество символов.
`passwd user01`
зайдя в домашнюю папку нового пользователя надо  `mkdir ssh && nano .ssh/autorized_keys` в редакторе нано добавить ssh пользователя и сохранить.

> netcat -l PORT - позволяет прослушивать какой-то порт  
> netcat ip:PORT - позволяет обращаться по ip к определенному порту ( но это не точно )

### Не высовывать наружу ненужные порты
https://selectel.ru/blog/tutorials/how-to-configure-firewall-with-ufw-on-ubuntu-20/
Если включить его не добавив исключения мы потеряем ВСЕ ПОРТЫ
Для этого можно использовать UFW разрешить работать с одним исключительным портом и закрыть остальные
```
sudo ufw allow 8822
sudo ufw enable
```
21:25 вернулся в тему


Чтобы иметь доступ к портам отвечающим за БД, нужно в конфиге на локальной машине внести изменения.  
Сделать форвардинг постов через ssh

```
Host timeweb 
  Hostname 147.45.137.195
  Port 8822
  IdentityFile ~/.ssh/timeweb
  User root
  LocalForward 8191 127.0.0.1:8090
  LocalForward 8181 127.0.0.1:8080
  LocalForward 5433 127.0.0.1:5432
 
```
Когда мы подключаемся по SSH у нас на машине открывается порт 8191, который буде связан с портом на сервере под 80:90


Чтобы дать рядовому пользователю возможность подключаться как суперпользователь без пароля
посмотреть группы `cat /etc/group` или редактировать через команду `nano /etc/group`
`cat /etc/sudoers`  поменять строку в разделе %sudo ALL=(ALL:ALL)  NOPASSWD: ALL


___
## DOCKER





___
## Занятие от 11.09. Подключение к проекту Payload. Создание кодовой базы из структуры БД
 пересмотреть с 10:30 до 10:37 - про докер, контейнеры и постгресс

### Установка Payload -10:40
Строка с подключением постгреса при установке, подразумевает что БД не требует авторизации.
Для подключения К БД перед адресом хоста необходимо добавил логин пароль  
`http://user:password@127.0.0.1:5432/db`
 11:04 Пэйлоад установлен - запущен, база данных подлкючена, но может конфликтовать с таблицами, которые относятся к  
приложению, для этого можно сделать префикс таблиц бд в orm
Работа с таблицами и схемами и разбор префикса таблиц
в  user.entity добавлена schema: 'typeorm'
11:27 
### генерация таблиц из существующей БД 11:30

Команда `npx typeorm-model-generator -h 127.0.01 -d db -u pguser -x pgPass -e postgres -o . -s public `
в каталоге в котором запускали скрипт получим большое количество файлов  описанием таблиц

### использоваение таблиц, в папке проекта, где необходимо применить таблицы - 11:35
`nest g posts`

11:45 запущен рабочий проект


___
## Занятие от 15.05. Миграции БД
Чтобы не смешивать таблицы в БД, в конфиг orm добавляется свойство schema:'typeorm' тогда все, что создается ОРМкой
будет попадат в эту схему.
Либо можно указать это свойство в Entities

При работе системы с несколькими базами данных, часть из которых создаются сторонней системой синхронизацию, включенную
в конфиге TypeOrm,  прописаном при его подключении к базовому модулю Nest необходимо отключить. Так как иначе она будет 
уничтожать все таблицы при перезапуске, в тч от стороннего сервиса.
В дальнейшем работа с БД ведется через Миграции

 ### НАстройка миграции - 28:00
В Конфиг Orm app.module добавляется свойство миграции:
`migrations: [join(__dirname, 'migrations', '*.{.ts,.js}')]` -
указываем где искать миграции
40:00 Ищем подходящие команды
Переходим в node_modules/.bin/typeorm-ts-node-commonjs
выполняем команду
```node_modules/.bin/typeorm-ts-node-commonjs migration:create src/migrations/create-db```
В указаном каталоге создастся миграция, это команду `typeorm-ts-node-commonjs migration:create src/migrations/create-db`
можно сохранить в package.json.  
### Создаем файл data source
Создаем файл migrations-data-source.ts в каталоге src
В этот файл импортируем ormCongfig from app.module.ts
импортируем { DataSource, DataSourceOptions } from 'typeorm';

export default new DataSource(<DataSourceOptions>ormConfig);
....

Занятие от  18.05 - Миграции и   Swagwer
первые 50 минут разбор проделанной работы над Миграциями.

## SWAGGER - 1:00
Библиотека свагер позволяет автоматически формировать документацию к API
Для автомтического формирования необходимо
`npm install @nestjs/swagger`, команда с официального сайта nestjs/openapi

В функцию bootstrap nestа, вставляется код с той-же страницы для работы свагера.
Далее в строке `SwaggerModule.setup('doc', app, document)` - doc - это адрес по которому на домене будет доступны данные api 
 до 1:18 - Изучение конфига Свагера.

В dto добавляются декорaторы __@ApiProperty()__  на каждое поле, которое обязательно и __@ApiPropertyOptional__ если свойство не обяательно
Внутрь декоратора можно задать объект со свойствами


## Занятие от 25.05 - Деплой на удаленный сервер

### Установка на компьютер под Виндой ВиртуалБокс с убунтой внутри. До 10:40

создание файла конфигурации

```
pg_hba.conf

#IPv4 local connections:
host all all 127.0.0.1/32 trust
host all all 0.0.0.0/0 md5

psql -U postgres -c "CREATE USER nodeapp_user WITH ENCRYPTED PASSWORD 'nodeapp_pass12345';"
psql -U postgres -c "CREATE DATABASE nodeapp_db;"
psql -U postgres -c "UPDATE pg_database SET encoding = pg_char_to_encoding('UTF8'), datcollate='en_US.UTF-8'"
psql -U postgres -c "CREATE USER nodeapp_user WITH ENCRYPTED PASSWORD 'nodeapp_pass12345';"
psql -U postgres -c "CREATE USER nodeapp_user WITH ENCRYPTED PASSWORD 'nodeapp_pass12345';"





nano /etc/systemd/system/nodeapp01.service

[Unit]
Description=nodeapp01
Requires=network-online.target
After=network-online.target

[Service]
Restart=on-failure
RestartSec=3s
WorkingDirectory=/home/user/{{catalog_name}}
ExecStart= node dist/main.js
User=user
Group=user

[Install]
WantedBy=multi-user.target

systemctl gaemond-reload

systemctl enable nodeapp // Подключить приложение
systemctl start nodeapp // Запустить приложение
systemctl --now enable nodeapp // Второй вариант , который запустит сервис сейчас

systemctl status nodeapp //Проаверить работу сервиса
systemctl stop nodeapp  //Остановить сервис
systemctl disable nodeapp //Отключить приложение

 journalctl -f -u nodeapp01 // Отслеживать логи системы
 
 #


13:00 решение проблемы с запуском VB
13:15 работа с настройко постгры и деплоя сервиса

``` 

##  Занятия от 29.05. Продолжение темы Деплоя.
 Подключаемся к виртуальной машине, на которой стоит голая убунту, заходим под Root.

У виртуал бокс есть возможность сделать снимок системы.
Обновляем систему командой  
`apt-get update`
`apt-get dist upgrade`
После чего делаем снимок системы
### Исправление миграций 0:35
Проверена работоспособность существующих сервисов
### Деплоймент 00:57
Сборка  прод версии продукта фронтенда.
Сбора прод версии бэкенда
При деплое используются 3 Каталога и 1 файл
* Client - Сбилженный фронтенд
* dist - Сбилженный Бекенд
* .env
*  package.json и p-lock.json - нельзя просто перенести папку node_modules, т.к. это может привести к сбоям из-за разницы ОС

### Собираем конечную версию продукта в одной папке 1:12 

### Прописываем настройки Postgress  1:18

