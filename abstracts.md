# Конспект по курсу BackEnd
___
## Занятие от 10.04.2024. Начало работы с TS
### Первые 20-30 минут - настройка среды под линукс.
### Начало работы с TS - 19:05
* Установить  ts глобально
 sudo npm install -g typescript
глобально устанавливается компилятор tsc.
* создать файл с расширением .ts
* скомпилировать ts в js
* Запустить ```node hello.js```

Код в обратную сторону провернуть нельзя.
### Инициализация проекта на ТС 19:28
```tsc --init```
создастся файл tsconfig.json, после его создания не обязательно передавать все файлы параметрами команды tsc
достаточно казать их  в tsconfig.json, после чего командой ```tsc``` компилируется весь проект.

### Пакет ts-node - 19:40
позволяет выполнять тайпскрипт без предварительной компиляции
```sudo npm install -g ts-node``` - удобно для разработки.
```ts-node -v```
```ts-node filename.ts```

### Перевод 12го проекта на ts - 19:47

При компиляции произойдет перевод кода в commonJs это надо учитывать и возможно изменить настройки в package.json

### Декораторы - 2:30

___

## Занятие от 16.04. Запуск проекта на NESTjs
### Глобальная установка Nestjs Командой ```sudo npm i -g @nestjs/cli```
 
CLI - Command Line Interface - Командный интерфейс, который позволяет автоматизировать некоторые процедуры в проекте  

```nest --help``` - позволяет увидеть все команды.  

```nest new "project_name"``` - создаст дирректорию и в ней проект  
```nest new --directory ./ "project_name"``` - Создает проект в существующей директории с заданным именем
### Решение конфликта с Гитом  с 00:38:00
При попытке сделать первый коммит возникает кофликт, так как Nest создал свой гит реопзиторий.
###  Запуск проекта. 00:50:00
### Порядок действия для запуска проекта 1:19:00
### Подключение переменных окражуения 1:30
У nestjs есть модуль config, который позволяет получать пременные окружения  
Для этого потребуется модуль ```npm install @nestjs/config```
Добавляем внутрь функции bootstrap в main.ts  
>const configService = app.get(ConfigService);
### Подключение импортов в Nestjs 1:39-1:43
Чтобы модуль стал доступен нужно в app.module.ts импортировать ConfigModule
в imports [] сконфигурировать, передав метод ConfigModule.forRoot ({})
### 1:43 - 1:47 - Решение проблемы с ipv6
Для корректного отображения ip-адреса приложения необходимо задать второй параметр

>await app.listen(port, '0.0.0.0'); 
 
### 1:47 - 2:07 Описание струкруры проекта в Nestjs

### 2:07 Проверка проекта в Postman

### Добавление в проект своих путей запросов и ответов.
По умолчанию в заголовке ответа Нест отвечает строкой "Hello world" для изменения этого поведения небоходимо изменить код в разделе
> AppService.ts

По умолчанию Нест получает входящие данные на роутер "/", изменить это поведение можно в контроллерах, добавив
строку с необходимым адресом в app.Controller.ts
В декоратор контроллера базовый роут
в декоратор Get строка для get запроса.


```
import { Controller, Get } from '@nestjs/common';
import { AppService, ITestResponse } from './app.service';

@Controller('/api/v1.0')
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('/contacts')
  getHello(): ITestResponse {
    return this.appService.getHello();
  }
}
```
Роут /api/ можно переопределить еще более глобально в main.ts 

### Переработка проекта с разделением на модули - 2:23.
Структура с изменениями в контроллер и сервис допустима только в случае, когда на весь 
проект 2-3 ендпоинта(роута), если роутов больше, необходимо разделение проекта на чатси.
Для этого используется CLI интерйфейс.

```
nest g res
```
после чего пишем имя ресурса, выбираем тип Rest Api, и подверждаем желание создания CRUD entry points
команда создает готовый круд модуль - дирректорию, содержащую:
* главный файл - модуль,
* Сервис с функциями обработки запроса
* Контроллер с энпоинтами и методами запроса
* entities (Сущности) - заготовка для взаимодействия с TypeOrm
* dto - Проверяет входные объекты получаемые из запросов, елси качественно составить dto не потребуется писать валидацию

### Изменение структуры проекта, удаление базового сервиса и контроллера - 2:37.
Для проектов с большим количеством ентрипоинтов можно из главного модуля удалить импорты:
* app.controller.ts
* app.service.ts


### Добавление статичных файлов фронтенда в проект - 2:43.

Выносим импорты в отдельные конфиги.
Добавляем модуль  `npm install @nestjs/serve-static`
ЧТобы сделать путь относительным потребуется метод **join** из node:path


___

## Занятие от 17.04. Подключение базы данных постгресс.
в каталоге Src:
```nest g res```
указываем сущность, которую хотим создать например "users"
ентер => yes
 создастся 5 файлов, нам нужны 3, без тестов

Модели БД лежат в папке entities, эти entities надо определить.

Реализуем подключение к БД. Для этого потребуется модуль TypeOrm

Выходим в каталог проекта, где лежит нода, там выполняем
```npm i @nestjs/typeorm typeorm pg```
в app.module.ts импортируем  typeorm и регистрируем его в импортах.

### Подключение переменных окружения и получение хоста БД. 00:37 - 00:50.
из ConfigService создается отдельный экземпляр и берем из него метод гет



```
const ormConfig: TypeOrmModuleOptions = {
 type: "postgres",\
 host: configService.get('NODEAPP_HOST', 'localhost' ),\
 port: ...\
 ...\
 entities: [join(__dirname, '**', '*.entity{.ts,.js}')] //файлы js нужны так как после компиляции ts не будет.\
 synchronize: true - в продакшене выключается в false
}
```

### Запуск проекта в 00:59 - Выпадает в ошибку окружений.
Импортируем config  from 'dotenv'
выполняем config();

### Создание первых таблиц в БД - 1:09.
Задекорировать классы в entities с помощью @Entity
  и дальше создается структура класса.
```
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity ()
export class Role{
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;
}
```
### Создание связей многих ко многим - 1:23
Для связи таблиц многие ко многим используется специальный декоратор
Перед импортом ентитис их надо зарегистрировать в module.ts
Далее для связи ентитис импортируются друг в друга
```
import { Entity, PrimaryGeneratedColumn, Column, ManyToMany } from 'typeorm';
import { Role } from '../../roles/entities/role.entity'
...
@ManyToMany( () => Role, (role) => role.users)
  roles: Role[];
```
 Перезапуск базы данных __1:27__ - изменения не актуализировались  
 Решение в __1:35__ - забыт важный декоратор
`@JoinTable()`  



### Создание дампа БД. 1:42.

В Дибивере - правый клик на базе данных - инструменты - резервная копия.
Не прокатит без локального установленного клиента постгреса. (Сервер из докеране прокатит)

Для создания Дампа БД используется ПГадмин.  
__1:46__ выгрузка дампа  и проблема с кодировкой.
__1:49__ - правильная выгрузка Дампа

### Работа с дампом 1:52.
Сокращение и доработка дампа Базы данных до 2:10.

### Доработка моделей пользователя и ролей
```
@Column( {nullable: true}) //позволяет оставлять поле пустым.
theDescription: string;
```

### Измененяем способ наименования в БД.  2:15
Устанавливаем модуль 
` npm instal typeorm-naming-strategies`

Добавляем его в конфиг orm
`namingStrategy: new SnakeNamingStrategy(),`

### Подготовка постман к работе с Апи. Копирование запросов. 2:27
 Импортируем InjectRepository в  Service
добавляем его в конструктор с помощью декоратора с приватным свойством userRepo  
` constructor(@InjectRepository(User) private userRepo: Repository<User>) {}`  
после чего обращаемся через this к этому свойству например так.
```
 findOne(id: string) {
    return this.userRepo.findOne({where: {id}});
  }
```

--- обрыв связи с 2:38 до 2:44  ---

### Описание DTO. 2:48
дЛя валидации данных устанавливается модуль 
`npm install class-validator`
После импорта с помощью декоратора можно использовать для валидации данных 

```
import { isString } from 'class-validator';
export class CreateUserDto {
  @isString()
  login: string;
  @isString()
  password: string;
}
```
___

## Занятие от 21.04. Добавление возможности связи между пользователями и ролями.

Первые 30 минут - попытка зпустить проект под виндой.  
32:00 Копирование коллекции в постман для ролей  
35:00 Копирование АПИ ролей и проверка стандартного круд.  
45:00 - Продумывание логики связывания ролей с пользователями  
53:00 - создали маршрут присвоения ролей в постмане  
### 56:00 - Создание логики в Апи
Прописываем метод в контроллере:
```
 @Patch('assign-roles/:id')
assignRoles(@Param( 'id') id: string, rolesDto: any) {
}
```

В конструктор класса user.services необходимо заинжектить и прописать сам метод
```
...
@Injectable()
export class UsersService {
constructor(@InjectRepository(User) private userRepo: Repository<User>,
@InjectRepository(Role) private roleRepo: Repository<Role>
){}
...
 async assignRoles(id: string, rolesDto: RolesDto) {
    const foundUser =  await this.userRepo.findOne({where: {id}}); //Проверяем что такой пользователь есть вбазе

  }
...

```
В модуль users.module в ентитиз необходимо добавить Role
```
...
import { Role } from '../roles/entities/role.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([User, Role]),
  ],
 ...
```
### Отсутствие понимания какую ошибку вернуть пользователю
1:25 - Написана логика работы с объектом пользователя.

```
 async assignRoles(id: string, rolesDto: RolesDto) {
try {
const foundUser = await this.userRepo.findOne({ where: { id } }); //Проверяем что такой пользователь есть вбазе

const roles: Array<Role>=[] // создаем массив ролей

  for (const roleId of rolesDto.roles) {
  roles.push(await  this.roleRepo.findOne({where: {id: roleId}}));
  }
  //validation Ok
  const updatedUser = await this.userRepo.save({ ...foundUser, roles });
  return updatedUser;
  } catch (err) {
  throw new BadRequestException({error: 'Error assign roles'});
  }
  }
```
Отправка запроса с пустыс массивом - снимает все роли с пользователя.

### Защита пароля в базе данных - 1:49.
Использование библиотеки для шифрования и хеширования bcrypt;
С помощью переменной saltOrRound можно зашифровать пароль. переменную обычно хранят в переменных окружения или на отдельном сервере.  
```
npm i bcrypt
npm i -D @types/bcrypt
```
__2:09__ - Проверка работоспособности защиты пароля. Все работает.

### Изменяем отправку данных пользователей, для удаления оттуда паролей. - 2:15
Добавляем декоратор `@Exclude` в entities - не работает.

в create-user.dto добавляем этот декоратор и получаем ошибку.  
__2:18__ - Для получения нужного результата в  user.entity декоратору добавляется 
объект `{select: false}`
```
  @Column({select: false})
password: string;
```
но при создании и изменении пользователя пароль все равно возвращается.  
__2:25__ - Поставленная задача решена, делаем коммит.

2:52 - пробуем добавить 2 одинаковых комплекта данных. и Фиксим это.


___
## ЗАнятие от 24.04. Аутентификация

### Работа с гитом
`git checkout -f` Возвращает последнее состояние проекта, которое было закоммичено в выбранной ветке

### Объяснение проделанной структуры работы. 18:48.
Зачем скидывать тесты в гит  
18:52 - Как просмотреть версии файлов в вебшторме, сохраненные в гите  
19:02 - База данных подключена, в ней есть необходимые таблицы.  
19:05 - Тестирование работы сервиса. Добавление данных.
19:09 - Объяснение структуры БД

### Вопрос про Репозитории. 19:14.
Подробное объяснение декораторов, контроллеров ентитис  
19:26 - Ентити менеджеры и репозитории, объяснение на примере документации TypeOrm  
19:20 - ПОтерял нить повествования  
19:35 - Объяснение на примере проекта, что такое репозиторий.

### Начало работы с аутентификацией. 19:53.
В документации Nestjs заходим в раздел Security/
Нам нужне раздел __Authentification__  
Рекомендуется пройти все шаги атентификации вручную, хотя-бы до  __Enable Authentification global__  
20:04 - Про библиотеку Pasport
### Работа с библиотекой Pasport. 20:07.
Объяснение, что будем делать дальше - подготовка постмана.
Для регистации на эндпоинт __signin__ будет уходить пост запрос с __username и password__  
20:19 - Объяснение работы с Токенами в Постмане
Для реализации аутентификации необходимо передавать соответствующий заголовок.

1:55 - Начало работы с проектом.  
Потребуется установить следующие модули:
```
npm install --save @nestjs/passport passport passport-local
npm install --save-dev @types/passport-local
```
потребуется создать модуль аутентификации, в каталоге src
```
nest g module auth
nest g controller auth
nest g service auth
```

2:00 - Модули созданы, объяснение разницы с созданием ресурсов. У модулей не создается ентитиз и дто.
Модули автоматически импортируются в app.modules
2:06 копирование метода findOne из User.
Получаем хеш пароля и выполняем поиск пользователя с параметром  
`where: {login: userName, password: passwordHash}` 
заменям запрос пароля на константу для исключения дублирования кода.
### Пишем сервис для аутентификации 2:13
Импортируем туда ЮзерСервис и пишем метод SignIn()
В AuthModule импортируем UsersModule
### Создаем контроллер и ДТО

### Написаны Сервисы, Контроллеры, ДТО модуля авторизации 
Падает с ошибкой 2:30.

В модуле аутентификации необходимо импортировать модули юсер и роль.  
2:37 получаем ошибку при любом пароле.

2:59 - Ошибка найдена, неправлиьно применялся метод при сравнивании паролей.
Для сравнения пароля юзера и пришедшего хеша используется метод bcrypt.compare()  
`return await bcrypt.compare(password, foundUser.password)`.
Но так как мы пароль не получаем с юзером метод не работает, нужно либо убрать 
`{select: false}` из  user.entity
Фиксится добавлением объект опций:
```
const foundUser = await this.userRepo.findOne({
        select: ['login', 'password'],
        where: { login: username }
      });
```
3:07 - Объяснение того, что было проделано.

___

## Занятие от 27.04.2024. Добавление Passport для работы с JWT.
18:37 - Вспоминаем проделанное.
18:40 идем по докусментации нест, раздел секьюрити - паспорт.
Добавляем локальную стратегию
### 19:01 существуют класс -  authGuard

19:17 - Запуск сервиса и проверка его жизнедеятельности.
Пока запускается докер слушаем вводную про CURL.
19:25 - проверка через постман, смена пароля пользователя, успешный результат.
19:28 - звонок до 19:31.
19:40 - объяснение Guarda. Он говорит фреймворку - когда приходит запрос - достается боди и запускает его данные в 
локальную стратегию из файла local.strategy.ts.
ДО 19:49 - Разбираем стратегии и  Guard

### JWT 19:50 
Устанавливаем необходимые модули.
```
npm install --save @nestjs/jwt passport-jwt
npm install --save-dev @types/passport-jwt
```
19:57 потерял нить
19:59 вернулся
20:14 не успел сообразить что куда передавать.